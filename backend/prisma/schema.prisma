generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  password      String
  name          String
  role          String    @default("CLIENT")
  phone         String?
  timezone      String    @default("America/Sao_Paulo")
  avatar        String?
  isEmailVerified Boolean  @default(false)
  emailVerificationToken String?
  resetPasswordToken     String?
  resetPasswordExpires   DateTime?
  isActive      Boolean   @default(true)
  lastLogin     DateTime?

  // Perfil profissional (card de apresentação e visibilidade)
  profileDescription String?  // O que o profissional oferece
  isProfileActive    Boolean  @default(true)  // Perfil visível para receber agendamentos
  
  // Sistema de Planos
  plan          String    @default("FREE") // FREE | SMART | PRO
  planStatus    String    @default("ACTIVE") // ACTIVE | CANCELLED | EXPIRED | TRIAL
  planStartDate DateTime?
  planEndDate   DateTime?
  subscriptionId String?  @unique // ID da subscription no gateway de pagamento
  trialEndsAt   DateTime?
  
  // Limites do plano
  maxAppointmentsPerMonth Int? // null = ilimitado
  maxProvidersPerAccount  Int? // null = ilimitado (para ADMIN)
  featuresEnabled String? // JSON com features habilitadas
  
  // Cliente cadastrado por um profissional (quem criou a conta do cliente)
  registeredByUserId String?
  registeredBy       User?   @relation("RegisteredByProvider", fields: [registeredByUserId], references: [id])
  registeredClients  User[]  @relation("RegisteredByProvider")

  appointmentsAsProvider Appointment[] @relation("ProviderAppointments")
  appointmentsAsClient  Appointment[] @relation("ClientAppointments")
  availabilities        Availability[]
  subscriptions         Subscription[]
  aiConfigurations      AIConfiguration[]
  refreshTokens         RefreshToken[]
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([email])
  @@index([role])
  @@index([plan])
  @@index([planStatus])
  @@index([registeredByUserId])
  @@map("users")
}

model RefreshToken {
  id        String    @id @default(cuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  jti       String    @unique  // JWT ID – identifica o token para revogação
  revokedAt DateTime?
  createdAt DateTime  @default(now())

  @@index([userId])
  @@index([jti])
  @@map("refresh_tokens")
}

// Enum convertido para String (SQLite não suporta enums)
// UserRole: ADMIN | PROVIDER | CLIENT

model Availability {
  id            String    @id @default(cuid())
  providerId    String
  provider      User      @relation(fields: [providerId], references: [id], onDelete: Cascade)
  
  dayOfWeek     Int
  startTime     String
  endTime       String
  isRecurring   Boolean   @default(true)
  startDate     DateTime?
  endDate       DateTime?
  timezone      String    @default("America/Sao_Paulo")
  slotDuration  Int       @default(30)
  bufferTime    Int       @default(0)
  maxBookingsPerSlot Int  @default(1)
  isActive      Boolean   @default(true)
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([providerId])
  @@index([dayOfWeek])
  @@index([isActive])
  @@map("availabilities")
}

model Appointment {
  id            String    @id @default(cuid())
  
  providerId    String
  provider      User      @relation("ProviderAppointments", fields: [providerId], references: [id], onDelete: Cascade)
  
  // Cliente pode ser NULL (agendamento público sem login)
  clientId      String?
  client        User?     @relation("ClientAppointments", fields: [clientId], references: [id], onDelete: Cascade)
  
  // Dados do cliente para agendamentos públicos
  clientName    String?
  clientEmail   String?
  clientPhone   String?
  
  // Token único para acesso público ao agendamento
  publicToken   String?   @unique
  
  startTime     DateTime
  endTime       DateTime
  duration      Int
  status        String    @default("PENDING")
  serviceType   String?
  title         String?
  description   String?
  location      String?
  meetingLink   String?
  reminderSent  Boolean   @default(false)
  reminderSentAt DateTime?
  confirmationSent Boolean @default(false)
  cancelledAt   DateTime?
  cancelledBy  String?
  cancellationReason String?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([providerId])
  @@index([clientId])
  @@index([startTime])
  @@index([status])
  @@index([providerId, startTime])
  @@index([publicToken])
  @@map("appointments")
}

// Enum convertido para String (SQLite não suporta enums)
// AppointmentStatus: PENDING | CONFIRMED | CANCELLED | COMPLETED | NO_SHOW

model Subscription {
  id              String    @id @default(cuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  plan            String    // FREE | SMART | PRO
  status          String    // ACTIVE | CANCELLED | EXPIRED | TRIAL
  gateway         String?   // STRIPE | MERCADOPAGO | etc
  gatewayId       String?   // ID no gateway de pagamento
  gatewayCustomerId String? // ID do customer no gateway
  
  currentPeriodStart DateTime?
  currentPeriodEnd   DateTime?
  cancelAtPeriodEnd Boolean  @default(false)
  cancelledAt       DateTime?
  
  // Histórico de pagamentos
  lastPaymentDate  DateTime?
  nextPaymentDate  DateTime?
  amount           Float?    // Valor em centavos ou decimal
  
  metadata         String?   // JSON com dados adicionais
  
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  
  @@index([userId])
  @@index([status])
  @@index([gatewayId])
  @@map("subscriptions")
}

model AIConfiguration {
  id              String    @id @default(cuid())
  userId          String    @unique
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Configurações de IA
  provider        String    @default("OPENAI") // OPENAI | ANTHROPIC | GEMINI | CUSTOM
  apiKey          String?   // Criptografado
  model           String    @default("gpt-4")
  temperature     Float     @default(0.7)
  maxTokens       Int       @default(1000)
  
  // Features de IA habilitadas
  autoResponder   Boolean   @default(false)
  smartScheduling  Boolean  @default(false)
  sentimentAnalysis Boolean @default(false)
  autoReminders   Boolean   @default(false)
  
  // Webhooks e integrações
  webhookUrl      String?
  webhookSecret   String?
  
  // Configurações customizadas
  customPrompt    String?
  settings        String?   // JSON com configurações adicionais
  
  isActive        Boolean   @default(true)
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([userId])
  @@index([provider])
  @@map("ai_configurations")
}

model WebhookLog {
  id              String    @id @default(cuid())
  userId          String?
  event           String    // appointment.created | appointment.cancelled | etc
  payload         String    // JSON do evento
  status          String    @default("PENDING") // PENDING | SUCCESS | FAILED
  attempts        Int       @default(0)
  lastAttemptAt   DateTime?
  responseCode    Int?
  responseBody    String?
  errorMessage    String?
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([userId])
  @@index([event])
  @@index([status])
  @@map("webhook_logs")
}
